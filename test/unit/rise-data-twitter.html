<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">

    <title>rise-data-twitter test</title>

    <script src="../../node_modules/@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
    <script src="../../node_modules/@polymer/test-fixture/test-fixture.js"></script>
    <script src="../../node_modules/mocha/mocha.js"></script>
    <script src="../../node_modules/chai/chai.js"></script>
    <script src="../../node_modules/wct-mocha/wct-mocha.js"></script>
    <script src="../../node_modules/sinon/pkg/sinon.js"></script>
    <script src="../../node_modules/object-hash/dist/object_hash.js"></script>

    <script type="text/javascript">
      RisePlayerConfiguration = {
        isConfigured: () => true,
        getPresentationId: () => "xxxx-yyyy"
      };
    </script>

    <script type="module" src="../../src/rise-data-twitter.js"></script>
  </head>
  <body>
    <test-fixture id="test-block">
      <template>
        <rise-data-twitter id="rise-data-twitter-01"></rise-data-twitter>
      </template>
    </test-fixture>

    <script type="module">
      suite("rise-data-twitter", () => {
        let sandbox = sinon.createSandbox();
        let element, clock, riseElement, fetchMixin;

        setup(() => {
          RisePlayerConfiguration.Logger = {
            info: () => {},
            warning: () => {},
            error: sinon.spy()
          };

          RisePlayerConfiguration.isPreview = () => {
            return false;
          };

          clock = sinon.useFakeTimers();

          element = fixture("test-block");

          fetchMixin = element.__proto__.__proto__;
          riseElement = element.__proto__.__proto__.__proto__.__proto__;

          sandbox.spy(riseElement, '_sendEvent');
          sandbox.stub(riseElement, '_setUptimeError');
        });

        teardown(()=>{
          sandbox.restore();
          clock.restore();
        });

        suite("properties", () => {
          test("should test element exists", () => {
            assert(element);
          });

          test("should set default for maxitems", () => {
            assert.equal(element.maxitems, 25);
          });
        });

        suite("ready", () => {
          let stub;

          setup(() => {
            stub = sandbox.stub(window, "addEventListener");
          });

          test("should listen for rise-components-ready and call init", () => {
            RisePlayerConfiguration.isConfigured = () => false;
            element.ready();

            assert.isTrue(stub.calledWith('rise-components-ready'));
          });

          test("should call _init() if RisePlayerConfiguration is configured", () => {
            RisePlayerConfiguration.isConfigured = () => true;
            sandbox.stub(element, '_init');

            element.ready();

            assert.isTrue(element._init.calledOnce);
            assert.isFalse(stub.calledOnce);
          });

          test("should setup handlers for viewer events", () => {
            sandbox.stub(element, "_reset");
            sandbox.stub(element, "_stop");

            element.dispatchEvent( new CustomEvent( "rise-presentation-play" ));
            element.dispatchEvent( new CustomEvent( "rise-presentation-stop" ));

            assert.isTrue(element._reset.calledOnce);
            assert.isTrue(element._stop.calledOnce);
          });

        });

        suite( "_reset", () => {
          setup( () => {
            sandbox.stub( element, "_stop" );
            sandbox.stub( element, "_start" );
          } );

          test( "should not execute reset when an initial start still pending", () => {
            element._reset();

            assert.isFalse( element._stop.calledOnce );
            assert.isFalse( element._start.calledOnce );
          } );

          test( "should execute reset when not the initial start", () => {
            element._initialStart = false;
            element._reset();

            assert.isTrue( element._stop.calledOnce );
            assert.isTrue( element._start.calledOnce );
          } );
        } );

        suite( "_start", () => {
          test( "coming soon ...", () => {

          } );
        } );

        suite( "_stop", () => {
          test( "coming soon ...", () => {

          } );
        } );

        suite( "_handleStart", () => {

          setup( () => {
            sandbox.stub( element, "_start" );
          } );

          test( "should call _start() when this is the initial 'start'", () => {
            const event = new CustomEvent( "start" );
            element.dispatchEvent( event );

            assert.isTrue( element._start.calledOnce );
            assert.isFalse( element._initialStart, "_initialStart set to false" );
          } );

          test( "should not call _start() when this is not the initial start", () => {
            element._initialStart = false;

            const event = new CustomEvent( "start" );
            element.dispatchEvent( event );

            assert.isFalse( element._start.called );
          } );

        } );

        suite( "_loadTweets", () => {
          setup( () => {
            sandbox.stub(element, "_getUrl").returns("https://service");
            sandbox.stub(fetchMixin, "fetch");
          });

          test( "should call fetch if username is set", () => {
            element.username = "@RiseVision";
            sandbox.resetHistory();

            element._loadTweets();

            assert.isTrue(element._getUrl.calledOnce);

            assert.isTrue(fetchMixin.fetch.calledOnce);
            assert.equal(fetchMixin.fetch.lastCall.args[0], "https://service");
          });

          test( "should not call fetch if username is not set", () => {
            element._loadTweets();

            assert.isFalse(element._getUrl.called);
            assert.isFalse(fetchMixin.fetch.called);
          });
        });

        suite( "_computeHash", () => {
          test( "should return a SHA1 hash value of provided params", () => {
            const presentationId = "21c97752-0b8b-4a0c-852c-83c0471a3e00",
              componentId = "rise-data-twitter-01",
              username = "cnn",
              expected = "7e5f08005453cdc84155be70574531e271e05644";

            const hash = element._computeHash(presentationId, componentId, username);

            assert.equal(hash, expected);
          });
        });

        suite( "_getUrl", () => {
          test( "should build URL", () => {
            element.username = "RiseVision";

            const hashVal = "f073a40c095e19635a4cb6ceeb8a554d0f88f55f",
              url = element._getUrl();

            assert.equal(url, `https://services-stage.risevision.com/twitter/get-presentation-tweets?presentationId=xxxx-yyyy&componentId=${element.id}&hash=${hashVal}&useDraft=false`);
          });

          test( "should account for @ character in username and ensure to remove it for computing hash", () => {
            element.username = "@RiseVision";

            const hashVal = "f073a40c095e19635a4cb6ceeb8a554d0f88f55f",
              url = element._getUrl();

            assert.equal(url, `https://services-stage.risevision.com/twitter/get-presentation-tweets?presentationId=xxxx-yyyy&componentId=${element.id}&hash=${hashVal}&useDraft=false`);
          });

          test( "should apply useDraft=true when running on Preview", () => {
            RisePlayerConfiguration.isPreview = () => {
              return true;
            };

            element.username = "RiseVision";

            const hashVal = "f073a40c095e19635a4cb6ceeb8a554d0f88f55f",
              url = element._getUrl();

            assert.equal(url, `https://services-stage.risevision.com/twitter/get-presentation-tweets?presentationId=xxxx-yyyy&componentId=${element.id}&hash=${hashVal}&useDraft=true`);
          });
        });

        suite( "_handleResponse", () => {
          test( "should handle a valid JSON response", () => {
            const json = sandbox.stub().resolves({});

            return element._handleResponse({json})
            .then(() => {
              assert.isTrue(json.calledOnce);
              assert.equal(riseElement._sendEvent.getCall(0).args[0], "data-update");

              assert.isTrue(riseElement._setUptimeError.calledOnce);
              assert.isFalse(riseElement._setUptimeError.lastCall.args[0]);
            });
          });

          test( "should handle an invalid JSON response", () => {
            const json = sandbox.stub().rejects({});

            return element._handleResponse({json})
            .then(() => {
              assert.isTrue(json.calledOnce);
              assert.equal(riseElement._sendEvent.getCall(0).args[0], "data-error");

              assert.isTrue(riseElement._setUptimeError.calledOnce);
              assert.isTrue(riseElement._setUptimeError.lastCall.args[0]);
            });
          });
        });

        suite( "_handleError", () => {
          test( "should handle error", () => {
            element._handleError(new Error("error"));

            assert.equal(riseElement._sendEvent.getCall(0).args[0], "request-error");

            assert.isTrue(riseElement._setUptimeError.calledOnce);
            assert.isTrue(riseElement._setUptimeError.lastCall.args[0]);
          });
        });

        suite( "logTypeForFetchError", () => {
          test( "should return error type for null error", () => {
            const eventType = element.logTypeForFetchError();

            assert.equal(eventType, "error");
          });

          test( "should return error type for error with no status", () => {
            const eventType = element.logTypeForFetchError({});

            assert.equal(eventType, "error");
          });

          test( "should return warning type for 403 status", () => {
            const eventType = element.logTypeForFetchError({ status: 403 });

            assert.equal(eventType, "warning");
          });

          test( "should return warning type for 429 status", () => {
            const eventType = element.logTypeForFetchError({ status: 429 });

            assert.equal(eventType, "warning");
          });

          test( "should return error type for 404 status with no response text", () => {
            const eventType = element.logTypeForFetchError({ status: 404 });

            assert.equal(eventType, "error");
          });

          test( "should return warning type for 404 status with username not found", () => {
            const eventType = element.logTypeForFetchError({
              status: 404,
              responseText: "Username not found: 'panchito'"
            });

            assert.equal(eventType, "warning");
          });

          test( "should return error type for 404 status with page not found", () => {
            const eventType = element.logTypeForFetchError({
              status: 404,
              responseText: "Page not found"
            });

            assert.equal(eventType, "error");
          });

          test( "should return error type for 500 status", () => {
            const eventType = element.logTypeForFetchError({ status: 500 });

            assert.equal(eventType, "error");
          });

          test( "should return error type for 400 status", () => {
            const eventType = element.logTypeForFetchError({ status: 400 });

            assert.equal(eventType, "error");
          });

          test( "should return error type for 409 status", () => {
            const eventType = element.logTypeForFetchError({ status: 409 });

            assert.equal(eventType, "error");
          });
        });

      });
    </script>
  </body>
</html>
