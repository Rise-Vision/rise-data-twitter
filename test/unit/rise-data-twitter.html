<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">

    <title>rise-data-twitter test</title>

    <script src="../../node_modules/@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
    <script src="../../node_modules/@polymer/test-fixture/test-fixture.js"></script>
    <script src="../../node_modules/mocha/mocha.js"></script>
    <script src="../../node_modules/chai/chai.js"></script>
    <script src="../../node_modules/wct-mocha/wct-mocha.js"></script>
    <script src="../../node_modules/sinon/pkg/sinon.js"></script>
    <script src="../../node_modules/jsencrypt/bin/jsencrypt.min.js"></script>

    <script type="text/javascript">
      RisePlayerConfiguration = {
        isConfigured: () => true,
        getPresentationId: () => "xxxx-yyyy"
      };
    </script>

    <script type="module" src="../../src/rise-data-twitter.js"></script>
  </head>
  <body>
    <test-fixture id="test-block">
      <template>
        <rise-data-twitter id="rise-data-twitter-01"></rise-data-twitter>
      </template>
    </test-fixture>

    <script type="module">
      suite("rise-data-twitter", () => {
        let sandbox = sinon.createSandbox();
        let element, clock, riseElement, fetchMixin;

        setup(() => {
          RisePlayerConfiguration.Logger = {
            info: () => {},
            warning: () => {},
            error: sinon.spy()
          };

          RisePlayerConfiguration.isPreview = () => {
            return false;
          };

          clock = sinon.useFakeTimers();

          element = fixture("test-block");

          fetchMixin = element.__proto__.__proto__;
          riseElement = element.__proto__.__proto__.__proto__.__proto__;

          sandbox.spy(riseElement, '_sendEvent');
          sandbox.stub(riseElement, '_setUptimeError');
        });

        teardown(()=>{
          sandbox.restore();
          clock.restore();
        });

        suite("properties", () => {
          test("should test element exists", () => {
            assert(element);
          });

          test("should set default for maxitems", () => {
            assert.equal(element.maxitems, 25);
          });
        });

        suite("ready", () => {
          let stub;

          setup(() => {
            stub = sandbox.stub(window, "addEventListener");
          });

          test("should listen for rise-components-ready and call init", () => {
            RisePlayerConfiguration.isConfigured = () => false;
            element.ready();

            assert.isTrue(stub.calledWith('rise-components-ready'));
          });

          test("should call _init() if RisePlayerConfiguration is configured", () => {
            RisePlayerConfiguration.isConfigured = () => true;
            sandbox.stub(element, '_init');

            element.ready();

            assert.isTrue(element._init.calledOnce);
            assert.isFalse(stub.calledOnce);
          });
        });

        suite( "_reset", () => {
          setup( () => {
            sandbox.stub( element, "_loadTweets" );
          } );

          test( "should not execute reset when an initial start still pending", () => {
            element._reset();

            assert.isFalse( element._loadTweets.calledOnce );
          } );

          test( "should execute reset when not the initial start", () => {
            element._initialStart = false;
            element._reset();

            assert.isTrue( element._loadTweets.calledOnce );
          } );
        } );

        suite( "_handleStart", () => {

          setup( () => {
            sandbox.stub( element, "_loadTweets" );
          } );

          test( "should call _loadTweets() when this is the initial 'start'", () => {
            const event = new CustomEvent( "start" );
            element.dispatchEvent( event );

            assert.isTrue( element._loadTweets.calledOnce );
            assert.isFalse( element._initialStart, "_initialStart set to false" );
          } );

          test( "should not call _loadTweets() when this is not the initial start", () => {
            element._initialStart = false;

            const event = new CustomEvent( "start" );
            element.dispatchEvent( event );

            assert.isFalse( element._loadTweets.called );
          } );
        } );

        suite( "_loadTweets", () => {
          setup( () => {
            sandbox.stub(element, "_getUrl").returns("https://service");
            sandbox.stub(fetchMixin, "fetch");
          });

          test( "should call fetch if username is set", () => {
            element.username = "@RiseVision";
            sandbox.resetHistory();

            element._loadTweets();

            assert.isTrue(element._getUrl.calledOnce);

            assert.isTrue(fetchMixin.fetch.calledOnce);
            assert.equal(fetchMixin.fetch.lastCall.args[0], "https://service");
          });

          test( "should not call fetch if username is not set", () => {
            element._loadTweets();

            assert.isFalse(element._getUrl.called);
            assert.isFalse(fetchMixin.fetch.called);
          });
        });

        suite( "_getUrl", () => {
          test( "should encrypt value", () => {
            const value = element._encryptParam("abc");
            const arbitraryMinExpectedLength = 100;
            assert.isTrue(value.length > arbitraryMinExpectedLength);

            // "/" and "+" characters always exist in the encrypted value.
            // Make sure they are encoded for use in URL
            assert.isTrue(value.indexOf("%2F") > 0, "forward slash is encoded");
            assert.isTrue(value.indexOf("%2B") > 0, "plus sign is encoded");
          });

          test( "should build URL", () => {
            element.username = "RiseVision";
            sandbox.stub(element, "_encryptParam").returns("ABC123");

            const url = element._getUrl();

            assert.equal(url, `https://services-stage.risevision.com/twitter/get-tweets-secure?presentationId=xxxx-yyyy&componentId=${element.id}&username=ABC123&count=25`);
          });

          test( "should account for @ character in username and ensure to remove it", () => {
            element.username = "@RiseVision";
            const stub = sandbox.stub(element, "_encryptParam");

            const url = element._getUrl();

            assert.isTrue(stub.calledWith('RiseVision'));
          });

          test("should return empty url string when presentation id is falsy", () => {
            const clone = Object.assign({}, RisePlayerConfiguration.getPresentationId);

            element.username = "@RiseVision";

            RisePlayerConfiguration.getPresentationId = () => {return null};

            assert.equal(element._getUrl(), "");

            RisePlayerConfiguration.getPresentationId = Object.assign({}, clone);
          });
        });

        suite( "_handleResponse", () => {
          test( "should handle a valid JSON response", () => {
            const json = sandbox.stub().resolves({});

            return element._handleResponse({json})
            .then(() => {
              assert.isTrue(json.calledOnce);
              assert.equal(riseElement._sendEvent.getCall(0).args[0], "data-update");

              assert.isTrue(riseElement._setUptimeError.calledOnce);
              assert.isFalse(riseElement._setUptimeError.lastCall.args[0]);
            });
          });

          test( "should handle an invalid JSON response", () => {
            const json = sandbox.stub().rejects({});

            return element._handleResponse({json})
            .then(() => {
              assert.isTrue(json.calledOnce);
              assert.equal(riseElement._sendEvent.getCall(0).args[0], "data-error");

              assert.isTrue(riseElement._setUptimeError.calledOnce);
              assert.isTrue(riseElement._setUptimeError.lastCall.args[0]);
            });
          });
        });

        suite( "_handleError", () => {
          test( "should handle error", () => {
            element._handleError(new Error("error"));

            assert.equal(riseElement._sendEvent.getCall(0).args[0], "request-error");

            assert.isTrue(riseElement._setUptimeError.calledOnce);
            assert.isTrue(riseElement._setUptimeError.lastCall.args[0]);
          });
        });

        suite( "logTypeForFetchError", () => {
          test( "should return error type for null error", () => {
            const eventType = element.logTypeForFetchError();

            assert.equal(eventType, "error");
          });

          test( "should return error type for error with no status", () => {
            const eventType = element.logTypeForFetchError({});

            assert.equal(eventType, "error");
          });

          test( "should return warning type for 403 status", () => {
            const eventType = element.logTypeForFetchError({ status: 403 });

            assert.equal(eventType, "warning");
          });

          test( "should return warning type for 429 status", () => {
            const eventType = element.logTypeForFetchError({ status: 429 });

            assert.equal(eventType, "warning");
          });

          test( "should return error type for 404 status with no response text", () => {
            const eventType = element.logTypeForFetchError({ status: 404 });

            assert.equal(eventType, "error");
          });

          test( "should return warning type for 404 status with username not found", () => {
            const eventType = element.logTypeForFetchError({
              status: 404,
              responseText: "Username not found: 'panchito'"
            });

            assert.equal(eventType, "warning");
          });

          test( "should return error type for 404 status with page not found", () => {
            const eventType = element.logTypeForFetchError({
              status: 404,
              responseText: "Page not found"
            });

            assert.equal(eventType, "error");
          });

          test( "should return error type for 500 status", () => {
            const eventType = element.logTypeForFetchError({ status: 500 });

            assert.equal(eventType, "error");
          });

          test( "should return error type for 400 status", () => {
            const eventType = element.logTypeForFetchError({ status: 400 });

            assert.equal(eventType, "error");
          });

          test( "should return error type for 409 status", () => {
            const eventType = element.logTypeForFetchError({ status: 409 });

            assert.equal(eventType, "error");
          });
        });

      });
    </script>
  </body>
</html>
